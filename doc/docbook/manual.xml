<?xml version='1.0' encoding='UTF-8'?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN" "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd">
<book lang="en">

	<bookinfo>
		<title>PSX Manual</title>
		<abstract>
			<para>This is the offical manual of the PSX framework.</para>
		</abstract>
	</bookinfo>

	<chapter id="introduction">
		<title>Introduction</title>
		<para>PSX is a framework written in PHP to create RESTful APIs. It helps you building clean URLs serving web 
		standard formats like JSON, XML, Atom and RSS. PSX helps you to create you application following a domain
		driven design approach. An PSX application is build of four parts. A handler system wich abstracts away the 
		actual SQL queries from the domain logic. Because of this system it makes no difference whether you get your
		data from an mysql database an api or an nosql system. An routing system wich executes the fitting controller method 
		depending on the location of the controller and the annotation of the method. A flexible data system to 
		import and export records into different formats like JSON, XML, Atom and RSS. And finally a domain system
		wich contains the domain problem of your application.</para>
		<para>PSX uses a lightweight DI container to handle dependencies wich implements the symfony DI container 
		interface. The controller can return request or response filter wich can react or modify the HTTP request or 
		response. PSX offers some basic request filter to handle i.e. Basic or Oauth authentication. In addition PSX 
		offers some cool components to use and implement OAuth, OpenID, Opengraph, Opensocial, Opensearch, PubSubHubbub, 
		WebFinger, Atom, and RSS. At the <ulink url="http://example.phpsx.org/">example</ulink> page you can see sample 
		implementations using various PSX classes.</para>
	</chapter>

	<chapter id="installation">
		<title>Installation</title>
		<para>The preferred way of installing PSX is to use composer and install the sample package. With this
		way you get an ready to use instance of PSX including some example to bootstrap your project.</para>
		<programlisting>php composer.phar create-project psx/sample .</programlisting>
		<para>If you only want use specific classes of PSX you can also require it via Composer. The package name is 
		psx/psx. More informations at <ulink url="http://packagist.org/packages/psx/psx">packagist.org</ulink></para>
	</chapter>

	<chapter id="configuration">
		<title>Configuration</title>
		<para>The config is an php array with key value pairs. You must change the key "psx_url" so that it
		points to the psx public root. All other entries are optional. The following table describes each entry.</para>
		<informaltable>
		<tgroup cols="2">
		<thead>
			<row>
				<entry>Key</entry>
				<entry>Description</entry>
			</row>
		</thead>
		<tbody>
			<row>
				<entry>psx_url</entry>
				<entry>The absolute url to the psx public folder (i.e. http://127.0.0.1/psx/public) or your domain
				name if you have setup a virutal host wich points to the public folder</entry>
			</row>
			<row>
				<entry>psx_dispatch</entry>
				<entry>Where we get the input path normally index.php/. If you use .htaccess to redirect all requestst 
				to the index.php you can also set this to ''</entry>
			</row>
			<row>
				<entry>psx_timezone</entry>
				<entry>The default timezone</entry>
			</row>
			<row>
				<entry>psx_gzip</entry>
				<entry>Whether to gzip the output of psx. The content gets only compressed if the browser support 
				gzip</entry>
			</row>
			<row>
				<entry>psx_debug</entry>
				<entry>Whether psx runs in debug mode or not. If not the error reporting is set to 0</entry>
			</row>

			<row>
				<entry>psx_sql_host</entry>
				<entry>Your sql host</entry>
			</row>
			<row>
				<entry>psx_sql_user</entry>
				<entry>Your sql user</entry>
			</row>
			<row>
				<entry>psx_sql_pw</entry>
				<entry>Your sql pw</entry>
			</row>
			<row>
				<entry>psx_sql_db</entry>
				<entry>Your sql db</entry>
			</row>

			<row>
				<entry>psx_routing</entry>
				<entry>Path to the routing file. Default is ../routes</entry>
			</row>
			<row>
				<entry>psx_error_template</entry>
				<entry>Path to an error template wich gets displayed if an error occured</entry>
			</row>
			<row>
				<entry>psx_path_cache</entry>
				<entry>The path to the cache folder. You can set this i.e. to /tmp</entry>
			</row>
			<row>
				<entry>psx_path_library</entry>
				<entry>The path to the library folder</entry>
			</row>
		</tbody>
		</tgroup>
		</informaltable>
	</chapter>

	<chapter id="routing">
		<title>Routing</title>
		<para>PSX uses by default a simple file based routing mechanism to redirect the incomming requests to a
		controller. See the file routes. Each routing definition must contain the following informations.</para>
		<programlisting>[method] [path] [controller]</programlisting>
		<para>In short that means the http request method, request path and the absolute class name of the controller. 
		I.e. to create a route wich will be called on GET /foo HTTP/1.1</para>
		<programlisting>GET /foo Foo\Application\Index</programlisting>
		<para>It is also possible to specify multiple request methods i.e. GET|POST. If you set a route to / this
		controller will always be used if no other controller was found. The routing mechanism chooses the route with the
		most conformance of the path. To explain this here an routing file and below a table to see wich controller
		gets called.</para>
		<programlisting>GET / Foo\Application\Index
GET /foo Foo\Application\Foo</programlisting>
		<informaltable>
		<tgroup cols="2">
		<thead>
			<row>
				<entry>Path</entry>
				<entry>Controller</entry>
			</row>
		</thead>
		<tbody>
			<row>
				<entry>/</entry>
				<entry>Foo\Application\Index</entry>
			</row>
			<row>
				<entry>/foo</entry>
				<entry>Foo\Application\Foo</entry>
			</row>
			<row>
				<entry>/foo/bar</entry>
				<entry>Foo\Application\Foo</entry>
			</row>
			<row>
				<entry>/bar</entry>
				<entry>Foo\Application\Index</entry>
			</row>
		</tbody>
		</tgroup>
		</informaltable>
		<para>You see that also on the request /foo/bar the Foo\Application\Foo controller gets called. This is intended
		because the controller itself can also specify path methods via annotation to control wich method gets called.
		This is also the place where you add dynamic placeholders. I.e. if you want have an url like /news/detail/[id]
		you should add a route /news to the controller and in the controller you should add the following method</para>
		<programlisting role="php"><![CDATA[
<?php

namespace Foo\Application;

use PSX\ModuleAbstract;

class News extends ModuleAbstract
{
	/**
	 * @httpMethod GET
	 * @path /
	 */
	public function doIndex()
	{
	}

	/**
	 * @httpMethod GET
	 * @path /detail/{id}
	 */
	public function doDetails()
	{
		$id = $this->getUriFragments('id');
	}

	/**
	 * @httpMethod POST
	 * @path /
	 */
	public function insertNews()
	{
	}
}

]]></programlisting>
		<para>Another advantage of such a routing file from a security perspective is that you get simply an overview
		wich endpoints can be requested by your application</para>
	</chapter>

	<!--
	<chapter id="domain">
		<title>Domain</title>
		<para></para>
	</chapter>
	-->

	<chapter id="developing-restful-api">
		<title>Developing a RESTful API</title>
		<para>This is the main chapter of the manual wich explains step by step howto develop a RESTful API based on 
		PSX. In this example we create a simple news API where you can create and receive news. If you have installed 
		the PSX Sample package this API is already included in the source code.</para>
		<sect1>
			<title>Setting up the table</title>
			<para>For our example we need a simple table called <property>news</property> where all records are 
			stored.</para>
			<example>
				<title><database>news</database> table</title>
				<programlisting role="sql"><![CDATA[
CREATE TABLE IF NOT EXISTS `news` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `userId` int(10) NOT NULL,
  `title` varchar(128) NOT NULL,
  `text` text NOT NULL,
  `date` datetime NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 ;
				]]></programlisting>
			</example>
		</sect1>
		<sect1>
			<title>Creating the handler</title>
			<para>The handler is a concept similar to a repository in doctrine wich abstracts the sql queries away from 
			the domain logic. Instead of creating sql queries you should add <methodname>getByFoo</methodname> methods to
			the handler. The Handler is also responsible to create, update and delete an record. In our case we tell
			the handler how the tabe looks and return an default select query.</para>
			<example>
				<title>library/Sample/News/Handler.php</title>
				<programlisting role="php"><![CDATA[
<?php

namespace Sample\News;

use PSX\Handler\DatabaseHandlerAbstract;
use PSX\Sql\Table;
use PSX\Sql\TableInterface;

class Handler extends DatabaseHandlerAbstract
{
	public function getTable()
	{
		return new Table($this->sql, 'news', array(
			'id' => TableInterface::TYPE_INT | 10 | TableInterface::PRIMARY_KEY,
			'userId' => TableInterface::TYPE_INT | 10,
			'title' => TableInterface::TYPE_VARCHAR | 128,
			'text' => TableInterface::TYPE_LONGTEXT,
			'date' => TableInterface::TYPE_DATETIME,
		));
	}

	protected function getDefaultSelect()
	{
		return $this->table
			->select(array('id', 'userId', 'title', 'text', 'date'));
	}
}
				]]></programlisting>
			</example>
		</sect1>
		<sect1>
			<title>Creating the domain</title>
			<para>The domain contains the core problem of your application. Your controller should not
			contain any complex logic it should call methods from your domain. In our case we have
			methods to get news entries and to create a new news entry. We also fire an event through
			the integrated symfony event dispatcher system if a record was successful created. Through
			the <classname>DomainAbstract</classname> class we can access all services from the di
			cotainer with <methodname>getXXX()</methodname>.</para>
			<example>
				<title>library/Sample/News/Domain.php</title>
				<programlisting role="php"><![CDATA[
<?php

namespace Sample\News;

use DateTime;
use PSX\Data\RecordInterface;
use PSX\Data\RecordEvent;
use PSX\Domain\DomainAbstract;
use PSX\Filter;
use PSX\Filter\Definition\Property;
use PSX\Filter\FilterDefinition;
use PSX\Validate;

class Domain extends DomainAbstract
{
	public function getAllNews($startIndex = null, $count = null, $sortBy = null, $sortOrder = null, Condition $con = null)
	{
		$news = $this->getDatabaseManager()->getHandler('Sample\News\Handler');

		return $news->getResultSet(array(),
			$startIndex, 
			$count, 
			$sortBy, 
			$sortOrder, 
			$con);
	}

	public function insertNews(RecordInterface $record)
	{
		$news = $this->getDatabaseManager()->getHandler('Foo\News\MysqlHandler');

		$this->getFilterDefinition()->validate($record);

		$record->setDate(new DateTime());

		$news->create($record);

		$this->dispatch('inserted', new RecordEvent($record));
	}

	protected function getFilterDefinition()
	{
		return new FilterDefinition($this->container->get('validate'), array(
			new Property('userId', Validate::TYPE_INTEGER)),
			new Property('title', Validate::TYPE_STRING, array(new Filter\Length(4, 32))),
			new Property('text', Validate::TYPE_STRING, array(new Filter\Length(4, 256))),
		));
	}
}

				]]></programlisting>
			</example>
		</sect1>
		<sect1>
			<title>The API endpoint</title>
			<para>We create a file called Index.php in the Sample/News/Api folder. After that we should add the following
			route.</para>
			<programlisting>GET|POST /news Sample\News\Api\Index</programlisting>
			<para>This API can be accessed via http://localhost/index.php/news. We define the <methodname>onLoad</methodname> 
			method wich is called when the module was loaded.</para>
			<para>This is now our REST API endpoint where we can make <property>GET</property> and <property>POST</property>
			requests.</para>
			<example>
				<title>library/Sample/News/Api/Index.php</title>
				<programlisting role="php"><![CDATA[
<?php

namespace Sample\News\Api;

use PSX\Module\ApiAbstract;

class Index extends ApiAbstract
{
	/**
	 * @httpMethod GET
	 * @path /
	 */
	public function doIndex()
	{
		try
		{
			$params = $this->getRequestParams();
			$fields = (array) $params['fields'];

			$news = $this->getDomainManager()
				->getDomain('Sample\News\Domain')
				->getAllNews($fields, 
					$params['startIndex'], 
					$params['count'], 
					$params['sortBy'], 
					$params['sortOrder'], 
					$this->getRequestCondition());

			$this->setResponse($news);
		}
		catch(\Exception $e)
		{
			$msg = new Message($e->getMessage(), false);

			$this->setResponse($msg);
		}
	}
}
				]]></programlisting>
			</example>
			<sect2>
				<title>Receiving</title>
				<para>If someone makes an <property>GET</property> request to the endpoint we want return the latest 
				news. Our domain class returns an <classname>PSX\Data\ResultSet</classname> object containing 
				multiple <classname>Sample\News\Record</classname> objects. If we call the <methodname>setResponse
				</methodname> method with the <classname>PSX\Data\ResultSet</classname> object the object is transformed 
				into the preferred format (wich was set either by the <property>GET</property> parameter "format" or by 
				the "Accept" header field).</para>
				<para>Because we want create an <property>Atom</property> feed we have to create an Atom record and 
				pass it to the <methodname>setResponse</methodname> method. We can map our existing records in the resultset 
				to the entries:</para>
				<example>
					<title>library/Sample/News/Api/Index.php (implement <methodname>getAtomRecord</methodname> method)</title>
					<programlisting role="php"><![CDATA[
protected function getAtomRecord(RecordInterface $result)
{
	$atom = new Atom();
	$atom->setTitle('News');
	$atom->setId(Uuid::nameBased($this->config['psx_url']));
	$atom->setUpdated($result->current()->getDate());

	$mapper = new Mapper();
	$mapper->setRule(array(
		'id'    => 'id',
		'title' => 'title',
		'text'  => new Rule('summary', function($text, array $row){
			return new Text($text, 'text');
		}),
		'date'  => 'updated',
	));

	foreach($result as $row)
	{
		$entry = new Atom\Entry();
		$mapper->map($row, $entry);

		$atom->add($entry);
	}

	return $atom;
}
					]]></programlisting>
				</example>
				<para>Now we have to convert our result set through the method <methodname>getAtomRecord</methodname>
				wich we have created if we create an ATOM feed.</para>
				<example>
					<title>library/Sample/News/Api/Index.php (update <methodname>doIndex</methodname> method)</title>
					<programlisting role="php"><![CDATA[
/**
 * @httpMethod GET
 * @path /
 */
public function doIndex()
{
	try
	{
		$params = $this->getRequestParams();
		$fields = (array) $params['fields'];

		$news = $this->getDomainManager()
			->getDomain('Sample\News\Domain')
			->getAllNews($fields, 
				$params['startIndex'], 
				$params['count'], 
				$params['sortBy'], 
				$params['sortOrder'], 
				$this->getRequestCondition());

		if($this->isWriter(WriterInterface::ATOM))
		{
			$this->setResponse($this->getAtomRecord($result));
		}
		else
		{
			$this->setResponse($result);
		}
	}
	catch(\Exception $e)
	{
		if($this->isWriter(WriterInterface::ATOM))
		{
			$msg = new Entry();
			$msg->setId(Uuid::nameBased($e->getMessage()));
			$msg->setTitle($e->getMessage());
			$msg->setUpdated(new DateTime());
		}
		else
		{
			$msg = new Message($e->getMessage(), false);
		}

		$this->setResponse($msg);
	}
}
					]]></programlisting>
				</example>
				<para>Here an example <property>GET</property> request with the response</para>
				<example>
					<title>Sample GET request</title>
					<programlisting><![CDATA[
GET /index.php/api/news HTTP/1.1
Host: 127.0.0.1
Connection: Keep-Alive
Accept: application/xml
					]]></programlisting>
				</example>
				<example>
					<title>Sample GET response</title>
					<programlisting role="xml"><![CDATA[
HTTP/1.1 200 OK
Date: Wed, 05 Jun 2013 22:18:22 GMT
Server: Apache/2.2.17 (Win32) mod_ssl/2.2.17 OpenSSL/0.9.8o PHP/5.3.4 mod_perl/2.0.4 Perl/v5.10.1
X-Powered-By: psx
Expires: Thu, 09 Oct 1986 01:00:00 GMT
Last-Modified: Thu, 09 Oct 1986 01:00:00 GMT
Cache-Control: no-store, no-cache, must-revalidate
Pragma: no-cache
Content-Length: 288
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Content-Type: application/xml

<?xml version="1.0" encoding="UTF-8"?>
<resultset>
 <totalResults>1</totalResults>
 <startIndex>0</startIndex>
 <itemsPerPage>16</itemsPerPage>
 <entry>
  <id>1</id>
  <userId>1</userId>
  <title>dsfsd</title>
  <text>fsdf</text>
  <date>2013-06-05 23:21:00</date>
 </entry>
</resultset>
					]]></programlisting>
				</example>
			</sect2>
			<sect2>
				<title>Inserting</title>
				<para>If someone makes a <property>POST</property> request we want insert the news in the table. We 
				get a new record through the handler and import the data through the <methodname>import</methodname> method.</para>
				<example>
					<title>library/Sample/News/Api/Index.php (implement <methodname>insertNews</methodname> method)</title>
					<programlisting role="php"><![CDATA[
/**
 * @httpMethod POST
 * @path /
 */
public function insertNews()
{
	try
	{
		$record = $this->getDatabaseManager()
			->getHandler('Sample\News\Handler')
			->getRecord();

		$this->import($record);

		// insert
		$news = $this->getDomainManager()
			->getDomain('Sample\News\Domain')
			->insertNews($record);

		$msg = new Message('You have successful create a ' . $record->getName(), true);

		$this->setResponse($msg);
	}
	catch(\Exception $e)
	{
		$msg = new Message($e->getMessage(), false);

		$this->setResponse($msg);
	}
}
					]]></programlisting>
				</example>
				<para>Here an example <property>POST</property> request to the API endpoint</para>
				<example>
					<title>Sample POST request</title>
					<programlisting role="xml"><![CDATA[
POST /projects/psx/public/index.php/news HTTP/1.1
Host: 127.0.0.1
User-Agent: Lynx 2.8.7
Accept: application/xml
Content-Type: application/xml

<news>
	<userId>1</userId>
	<title>foo</title>
	<text>bar</text>
</news>
					]]></programlisting>
				</example>
				<example>
					<title>Sample POST response</title>
					<programlisting role="xml"><![CDATA[
HTTP/1.1 200 OK
Date: Wed, 05 Jun 2013 22:20:35 GMT
Server: Apache/2.2.17 (Win32) mod_ssl/2.2.17 OpenSSL/0.9.8o PHP/5.3.4 mod_perl/2.0.4 Perl/v5.10.1
X-Powered-By: psx
Expires: Thu, 09 Oct 1986 01:00:00 GMT
Last-Modified: Thu, 09 Oct 1986 01:00:00 GMT
Cache-Control: no-store, no-cache, must-revalidate
Pragma: no-cache
Content-Length: 133
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Content-Type: application/xml

<?xml version="1.0" encoding="UTF-8"?>
<message>
 <text>You have successful create a news</text>
 <success>true</success>
</message>
					]]></programlisting>
				</example>
			</sect2>
		</sect1>
		<sect1>
			<title>Conclusion</title>
			<para>This example has shown you howto build an API with PSX wich serves content in <property>Atom
			</property>, <property>Json</property> and <property>XML</property> on an 
			<property>GET</property> request. Also it is possible to insert new records with a <property>POST</property> 
			request. You can specify the fields wich are selected with the parameter fields i.e. "fields=id,title" to 
			select only the id and title.</para>
		</sect1>
	</chapter>

	<chapter id="api-authorization">
		<title>API authorization</title>
		<para>It is often the case that you want that only registered users can POST new entries to the API endpoint. In 
		this case the user has to authorize before submitting a new record. PSX offers several authorization methods for 
		your API. In this chapter we will look at different authentication methods and howto implement them.</para>
		<sect1>
			<title>Basic authentication</title>
			<para>Basic authentication is the most simple authentication method where a user provides an username and 
			password in the header. Note if you use basic authentication you should use https since the username and 
			password is transported in plaintext over the wire. Add the following method to the news API in order to add 
			basic authentication.</para>
			<example>
				<title>module/api/news.php (add basic authentication)</title>
				<programlisting role="php"><![CDATA[
use PSX\Dispatch\RequestFilter\BasicAuthentication;

...

public function getRequestFilter()
{
	$auth = new BasicAuthentication(function($username, $password){

		if($username == '[username]' && $password == '[passsword]')
		{
			return true;
		}

		return false;

	});

	return array($auth);
}
				]]></programlisting>
			</example>
		</sect1>
		<sect1>
			<title>Oauth authentication</title>
			<para>-</para>
			<example>
				<title>module/api/news.php (add oauth authentication)</title>
				<programlisting role="php"><![CDATA[
use PSX\Dispatch\RequestFilter\OauthAuthentication;
use PSX\Oauth\Provider\Data\Consumer;

...

public function getRequestFilter()
{
	$auth = new OauthAuthentication(function($consumerKey, $token){

		// this is only to illustrate what to return. Normally you have to check
		// - is it a valid consumerKey
		// - does the token belongs to an valid request with a valid status
		// - is the token not expired
		// PSX calculates and compares the signature if you return an consumer.
		// For more informations see http://tools.ietf.org/html/rfc5849
		if($consumerKey == '[consumerKey]' && $token == '[token]')
		{
			return new Consumer('[consumerKey]', '[consumerSecret]', '[token]', '[tokenSecret]');
		}

		return false;

	});

	return array($auth);
}
				]]></programlisting>
			</example>
		</sect1>
	</chapter>

	<chapter id="oauth-based-api-authorization">
		<title>Oauth implementation</title>
		<para>If you want offer an Oauth endpoint for applications PSX offers some classes to implement the Oauth 1.0 
		specification. In the following section we will implement a basic Oauth endpoint where a client can get tokens 
		and access an protected API. More informations about Oauth at <ulink url="http://tools.ietf.org/html/rfc5849">
		rfc5849</ulink>.</para>
		<sect1>
			<title>Setting up the table</title>
			<para>In order to store the Oauth requests we use the following table</para>
			<example>
				<title><database>request</database> table</title>
				<programlisting role="sql"><![CDATA[
CREATE TABLE IF NOT EXISTS `request` (
  `id` int(10) NOT NULL AUTO_INCREMENT,
  `ip` varchar(128) NOT NULL,
  `token` varchar(40) NOT NULL,
  `tokenSecret` varchar(40) NOT NULL,
  `nonce` varchar(32) NOT NULL,
  `verifier` varchar(16) DEFAULT NULL,
  `authorized` int(1) NOT NULL DEFAULT '0',
  `callback` varchar(256) DEFAULT NULL,
  `exchangeDate` datetime DEFAULT NULL,
  `authorizationDate` datetime DEFAULT NULL,
  `insertDate` datetime NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `token` (`token`),
  UNIQUE KEY `tokenSecret` (`tokenSecret`),
  UNIQUE KEY `nonce` (`nonce`),
  UNIQUE KEY `verifier` (`verifier`)
) ENGINE=MyISAM  DEFAULT CHARSET=utf8 ;
				]]></programlisting>
			</example>
		</sect1>
		<sect1>
			<title>Oauth endpoints</title>
			<para>In order to enable Oauth authentication we have to implement the following endpoints like defined in 
			the specification.</para>
			<informaltable>
			<tgroup cols="2">
			<thead>
				<row>
					<entry>Endpoint</entry>
					<entry>Location</entry>
				</row>
			</thead>
			<tbody>
				<row>
					<entry><link linkend="temporary-credential-request">Temporary Credential Request</link></entry>
					<entry>http://localhost/index.php/api/request</entry>
				</row>
				<row>
					<entry><link linkend="resource-owner-authorization">Resource Owner Authorization</link></entry>
					<entry>http://localhost/index.php/api/auth</entry>
				</row>
				<row>
					<entry><link linkend="token-request">Token Request</link></entry>
					<entry>http://localhost/index.php/api/access</entry>
				</row>
			</tbody>
			</tgroup>
			</informaltable>
			<sect2 id="temporary-credential-request">
				<title>Temporary Credential Request</title>
				<para>This endpoint is for obtaining an temporary credential.</para>
				<example>
					<title>module/api/request.php</title>
					<programlisting role="php"><![CDATA[
<?php

namespace api;

use PSX\DateTime;
use PSX\Exception;
use PSX\Oauth\Provider\RequestAbstract;
use PSX\Oauth\Provider\Data;

class request extends RequestAbstract
{
	public function onLoad()
	{
		try
		{
			// if we call the handle method the OAuth request is proccessed and
			// the getConsumer() and getResponse() method is called
			$this->handle();
		}
		catch(\Exception $e)
		{
			header('HTTP/1.1 500 Internal Server Error');

			echo $e->getMessage();

			if($this->config['psx_debug'] === true)
			{
				echo "\n\n" . $e->getTraceAsString();
			}
		}
	}

	protected function getConsumer($consumerKey)
	{
		if($consumerKey == $this->config['consumer_key'])
		{
			return new Data\Consumer($this->config['consumer_key'], $this->config['consumer_secret']);
		}
		else
		{
			throw new Exception('Invalid consumer key');
		}
	}

	protected function getResponse(Data\Consumer $consumer, Data\Request $request)
	{
		// generate tokens
		$token       = sha1(uniqid(mt_rand(), true));
		$tokenSecret = sha1(uniqid(mt_rand(), true));

		// insert request
		$this->getSql()->insert('request', array(

			'ip'          => $_SERVER['REMOTE_ADDR'],
			'token'       => $token,
			'tokenSecret' => $tokenSecret,
			'nonce'       => $request->getNonce(),
			'callback'    => $request->getCallback(),
			'insertDate'  => date(DateTime::SQL),

		));

		// return response
		$response = new Data\Response();
		$response->setToken($token);
		$response->setTokenSecret($tokenSecret);

		return $response;
	}
}

					]]></programlisting>
				</example>
			</sect2>
			<sect2 id="resource-owner-authorization">
				<title>Resource Owner Authorization</title>
				<para>If the Oauth client has obtained the temporary credential the user will be redirected to the 
				<property>Resource Owner Authorization</property> endpoint.</para>
				<example>
					<title>module/api/auth.php</title>
					<programlisting role="php"><![CDATA[
<?php

namespace api;

use PSX\Exception;
use PSX\DateTime;
use PSX\Url;
use PSX\ModuleAbstract;
use PSX\Sql\Condition;

class auth extends ModuleAbstract
{
	public function onLoad()
	{
		$token = isset($_GET['oauth_token']) ? $_GET['oauth_token'] : null;

		if(!empty($token))
		{
			$row = $this->getSql()->getRow('SELECT `id`, `ip`, `token`, `authorized`, `callback`, `insertDate` FROM `request` WHERE `token` = ?', array($token));

			if(!empty($row))
			{
				// @todo normally we have to check here whether the current user
				// is authenticated. If not the user has to login. Then a form 
				// should be displayed whether the user wants to grant or deny 
				// the application. If the user allows the application we 
				// approve the request. To simplify things we acccept the 
				// request on load

				// validate
				if($_SERVER['REMOTE_ADDR'] != $row['ip'])
				{
					throw new Exception('Token was requested from another ip');
				}

				if($row['authorized'] != 0)
				{
					throw new Exception('Token was already authorized');
				}

				// @todo check the insertDate whether token is expired

				// generate verifier
				$verifier = substr(sha1(uniqid(mt_rand(), true)), 0, 16);

				// update request
				$con = new Condition(array('id', '=', $row['id']));

				$this->getSql()->update('request', array(

					'verifier'          => $verifier,
					'authorized'        => 1,
					'authorizationDate' => date(DateTime::SQL),

				), $con);

				// redirect user or display verifier
				if($row['callback'] != 'oob')
				{
					$url = new Url($row['callback']);
					$url->addParam('oauth_token', $row['token']);
					$url->addParam('oauth_verifier', $verifier);

					header('Location: ' . strval($url));
					exit;
				}
				else
				{
					echo '<p>You have successful authorized a token. Please provide the following verifier to your application in order to complete the authorization proccess.</p>';
					echo '<p>Verifier:</p><p><b>' . $verifier . '</b></p>';
				}
			}
			else
			{
				throw new Exception('Invalid token');
			}
		}
		else
		{
			throw new Exception('Token not set');
		}
	}
}
					]]></programlisting>
				</example>
			</sect2>
			<sect2 id="token-request">
				<title>Token Request</title>
				<para>-</para>
				<example>
					<title>module/api/access.php</title>
					<programlisting role="php"><![CDATA[
<?php

namespace api;

use PSX\DateTime;
use PSX\Exception;
use PSX\Oauth\Provider\AccessAbstract;
use PSX\Oauth\Provider\Data;
use PSX\Sql\Condition;

class access extends AccessAbstract
{
	protected $id;
	protected $nonce;
	protected $verifier;

	public function onLoad()
	{
		try
		{
			// if we call the handle method the OAuth request is proccessed and
			// the getConsumer() and getResponse() method is called
			$this->handle();
		}
		catch(\Exception $e)
		{
			header('HTTP/1.1 500 Internal Server Error');

			echo $e->getMessage();

			if($this->config['psx_debug'] === true)
			{
				echo "\n\n" . $e->getTraceAsString();
			}

			exit;
		}
	}

	protected function getConsumer($consumerKey, $token)
	{
		if($consumerKey == $this->config['consumer_key'])
		{
			$row = $this->getSql()->getRow('SELECT id, nonce, verifier, token, tokenSecret FROM request WHERE token = ? AND authorized = 1', array($token));

			if(!empty($row))
			{
				$this->id       = $row['id'];
				$this->nonce    = $row['nonce'];
				$this->verifier = $row['verifier'];

				return new Data\Consumer($this->config['consumer_key'], $this->config['consumer_secret'], $row['token'], $row['tokenSecret']);
			}
			else
			{
				throw new Exception('Invalid token');
			}
		}
		else
		{
			throw new Exception('Invalid consumer key');
		}
	}

	protected function getResponse(Data\Consumer $consumer, Data\Request $request)
	{
		// validate
		if($this->nonce == $request->getNonce())
		{
			throw new Exception('Nonce hasnt changed');
		}

		if($this->verifier != $request->getVerifier())
		{
			throw new Exception('Invalid verifier');
		}

		// generate a new access token
		$token       = sha1(uniqid(mt_rand(), true));
		$tokenSecret = sha1(uniqid(mt_rand(), true));

		// update request
		$con = new Condition(array('id', '=', $this->id));

		$this->getSql()->update('request', array(

			'authorized'   => 2,
			'token'        => $token,
			'tokenSecret'  => $tokenSecret,
			'exchangeDate' => date(DateTime::SQL),

		), $con);

		// return response
		$response = new Data\Response();
		$response->setToken($token);
		$response->setTokenSecret($tokenSecret);

		return $response;
	}
}

					]]></programlisting>
				</example>
			</sect2>
		</sect1>
		<sect1>
			<title>Protect the API endpoint</title>
			<para>Now we can protect our API like defined in the "API authorization" chapter. Here an simple 
			implementation.</para>
			<example>
				<title>module/api/news.php (add oauth authentication)</title>
				<programlisting role="php"><![CDATA[
public function getRequestFilter()
{
	$config = $this->getConfig();
	$sql    = $this->getSql();

	$auth = new OauthAuthentication(function($consumerKey, $token) use ($config, $sql){

		if($consumerKey == $config['consumer_key'])
		{
			$row = $sql->getRow('SELECT token, tokenSecret FROM request WHERE token = ? AND authorized = 2', array($token));

			if(!empty($row))
			{
				return new Data\Consumer($config['consumer_key'], $config['consumer_secret'], $row['token'], $row['tokenSecret']);
			}
			else
			{
				throw new Exception('Invalid token');
			}
		}
		else
		{
			throw new Exception('Invalid consumer key');
		}

	});

	return array($auth);
}
				]]></programlisting>
			</example>
			<sect2>
				<title>Inserting</title>
				<para>Here an example Oauth request to insert a news</para>
				<example>
					<title>Sample POST request</title>
					<programlisting><![CDATA[
POST /index.php/api/news HTTP/1.1
Host: 127.0.0.1
Connection: Keep-Alive
Content-Type: application/xml
Authorization: OAuth realm="Aletheia", oauth_signature="iH%2Frqr8h%2Bv74G0UhV2i9ikasSxM%3D", oauth_version="1.0", oauth_nonce="b86440fa6e025b41820cdf8f6124ceaa", oauth_signature_method="HMAC-SHA1", oauth_consumer_key="19b6db8e0de8a287f65a2ae83d6b4f88", oauth_token="88ad358b1e983ac293b290b7547c3dbc28bc92f7", oauth_timestamp="1370551822"
Content-Length: 72
Expect: 100-continue

<news>
	<userId>1</userId>
	<title>foo</title>
	<text>bar</text>
</news>
					]]></programlisting>
				</example>
				<example>
					<title>Sample POST response</title>
					<programlisting><![CDATA[
HTTP/1.1 200 OK
Date: Thu, 06 Jun 2013 20:50:22 GMT
Server: Apache/2.2.17 (Win32) mod_ssl/2.2.17 OpenSSL/0.9.8o PHP/5.3.4 mod_perl/2.0.4 Perl/v5.10.1
X-Powered-By: psx
Expires: Thu, 09 Oct 1986 01:00:00 GMT
Last-Modified: Thu, 09 Oct 1986 01:00:00 GMT
Cache-Control: no-store, no-cache, must-revalidate
Pragma: no-cache
Content-Length: 59
Keep-Alive: timeout=5, max=100
Connection: Keep-Alive
Content-Type: application/json

{"text":"You have successful create a news","success":true}
					]]></programlisting>
				</example>
			</sect2>
		</sect1>
		<sect1>
			<title>Conclusion</title>
			<para>This was an basic example howto create an Oauth endpoint and to protect your API.</para>
			<para>Note: This is an example implementation to show you the basic functionality howto use the Oauth 
			classes of PSX. Because of simplicity we use only a single consumer key and consumer secret normally you 
			would save those in a table and generate per application a consumer key and secret. Please see the 
			<ulink url="http://amun.phpsx.org">Amun</ulink> project for a real implementation of the OAuth classes.
			</para>
		</sect1>
	</chapter>

	<chapter id="record">
		<title>Import data into records</title>
		<para>This chapter explains more detailed howto define and import data into records. As example we use the 
		following <property>News</property> and <property>User</property> records.</para>
		<example>
			<title>Sample news record</title>
			<programlisting role="php"><![CDATA[
<?php

namespace Test\News;

use DateTime;
use Test\User;
use PSX\Data\RecordAbstract;

class News extends RecordAbstract
{
	protected $id;
	protected $author;
	protected $to;
	protected $title;
	protected $date;

	public function getName()
	{
		return 'news';
	}

	public function getFields()
	{
		return array(
			'id'     => $this->id,
			'author' => $this->author,
			'to'     => $this->to,
			'title'  => $this->title,
			'date'   => $this->date,
		);
	}

	/**
	 * @param integer $id
	 */
	public function setId($id)
	{
		$this->id = $id;
	}

	/**
	 * @param \Test\User\Record $user
	 */
	public function setAuthor(User\Record $author)
	{
		$this->author = $author;
	}

	/**
	 * @param array<\Test\User\Record> $user
	 */
	public function setTo(array $to)
	{
		$this->to = $to;
	}

	/**
	 * @param string $title
	 */
	public function setTitle($title)
	{
		$this->title = $title;
	}

	/**
	 * @param DateTime $date
	 */
	public function setDate(DateTime $date)
	{
		$this->date = $date;
	}
}
			]]></programlisting>
		</example>
		<example>
			<title>Sample user record</title>
			<programlisting role="php"><![CDATA[
<?php

namespace Test\User;

use PSX\Data\RecordAbstract;

class User extends RecordAbstract
{
	protected $id;
	protected $name;

	public function getName()
	{
		return 'user';
	}

	public function getFields()
	{
		return array(
			'id'   => $this->id,
			'name' => $this->name,
		);
	}

	/**
	 * @param integer $id
	 */
	public function setId($id)
	{
		$this->id = $id;
	}

	/**
	 * @param string $name
	 */
	public function setName($name)
	{
		$this->name = $name;
	}
}
			]]></programlisting>
		</example>
		<para>In abstract a record is a collection of key value pairs. The key is an string and the value can be either 
		an scalar value or an object itself. The <methodname>getFields</methodname> method returns an array 
		representation of the record.</para>
		<para>If you import an request into the record the annotations of the setter methods are parsed. That means
		if your param is an integer PSX will cast the value to integer. If the parameter is an class name then an object 
		is created of this class. If the class is an instance of PSX\Data\RecordInterface the data is imported else 
		the value is passed to the constructor. So in the example news record at the <methodname>setDate
		</methodname> method the value is passed to the DateTime contructor. It is also possible to accept an array
		of variables or class names see the <methodname>setTo</methodname> method. In order to create a new news 
		record we would send the following JSON or XML data.</para>
		<programlisting role="php"><![CDATA[
{
	author: {
		name: "foo"
	},
	to: [{
		name: "bar"
	},{
		name: "test"
	}]
	title: "foo",
	date: "2013-06-28 18:50:00",
}
		]]></programlisting>
		<programlisting role="php"><![CDATA[
<news>
	<author>
		<name>foo</name>
	</author>
	<to>
		<name>bar</name>
	</to>
	<to>
		<name>test</name>
	</to>
	<title>foo</title>
	<date>2013-06-28 18:50:00</date>
</news>
		]]></programlisting>
	</chapter>

	<chapter id="help">
		<title>Help</title>
		<para>Because PSX is in an early stage the manual is not complete. We appreciate every help in making this 
		documentation better. The documentation is writte in XML against the docbook specification. You can checkout the 
		current version of this manual via GIT. The XML file is in doc/docbook/manual.xml.</para>
		<orderedlist numeration="upperroman">
		<title>Further reading about PSX</title>
		<listitem>
			<para>Repository: <ulink url="https://github.com/k42b3/psx">https://github.com/k42b3/psx</ulink></para>
		</listitem>
		<listitem>
			<para>Bugtracker: <ulink url="https://github.com/k42b3/psx/issues">https://github.com/k42b3/psx/issues</ulink></para>
		</listitem>
		<listitem>
			<para>Website: <ulink url="http://phpsx.org">http://phpsx.org</ulink></para>
		</listitem>
		<listitem>
			<para>Examples: <ulink url="http://example.phpsx.org">http://example.phpsx.org</ulink></para>
		</listitem>
		</orderedlist>
	</chapter>

</book>
